<?php
/**
 * ChannelState
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  Supla\ApiClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * SUPLA Cloud API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 25.03
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Supla\ApiClient\Model;

use \ArrayAccess;
use \Supla\ApiClient\ObjectSerializer;

/**
 * ChannelState Class Doc Comment
 *
 * @category Class
 * @description The channel&#39;s state. The value and the format depends on the channel&#39;s function. Read more on [Github Wiki](https://github.com/SUPLA/supla-cloud/wiki/Channel-Functions-states).
 * @package  Supla\ApiClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class ChannelState implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'ChannelState';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'connected' => 'bool',
        'connectedCode' => 'string',
        'brightness' => 'int',
        'on' => 'bool',
        'color' => 'string',
        'colorBrightness' => 'int',
        'depth' => 'int',
        'distance' => 'int',
        'value' => 'float',
        'support' => 'int',
        'totalCost' => 'float',
        'pricePerUnit' => 'float',
        'currency' => 'string',
        'phases' => '\Supla\ApiClient\Model\ChannelStateElectricityMeterPhase[]',
        'hi' => 'bool',
        'partialHi' => 'bool',
        'humidity' => 'float',
        'temperature' => 'float',
        'heating' => 'bool',
        'cooling' => 'bool',
        'manual' => 'bool',
        'countdownTimer' => 'bool',
        'thermometerError' => 'bool',
        'clockError' => 'bool',
        'forcedOffBySensor' => 'bool',
        'weeklyScheduleTemporalOverride' => 'bool',
        'batteryCoverOpen' => 'bool',
        'calibrationError' => 'bool',
        'mode' => 'string',
        'temperatureHeat' => 'float',
        'temperatureCool' => 'float',
        'temperatureMain' => 'float',
        'humidityMain' => 'float',
        'impulsesPerUnit' => 'int',
        'counter' => 'int',
        'calculatedValue' => 'float',
        'unit' => 'string',
        'currentOverload' => 'bool',
        'isCalibrating' => 'bool',
        'notCalibrated' => 'bool',
        'shut' => 'int',
        'closed' => 'bool',
        'manuallyClosed' => 'bool',
        'flooding' => 'bool',
        'executing' => 'bool',
        'initiatorTypeId' => 'int',
        'initiatorType' => 'string',
        'initiatorId' => 'int',
        'initiatorName' => 'string',
        'millisecondsFromStart' => 'int',
        'millisecondsToEnd' => 'int',
        'tiltPercent' => 'int',
        'tiltAngle' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'connected' => null,
        'connectedCode' => null,
        'brightness' => null,
        'on' => null,
        'color' => null,
        'colorBrightness' => null,
        'depth' => null,
        'distance' => null,
        'value' => null,
        'support' => null,
        'totalCost' => null,
        'pricePerUnit' => null,
        'currency' => null,
        'phases' => null,
        'hi' => null,
        'partialHi' => null,
        'humidity' => null,
        'temperature' => null,
        'heating' => null,
        'cooling' => null,
        'manual' => null,
        'countdownTimer' => null,
        'thermometerError' => null,
        'clockError' => null,
        'forcedOffBySensor' => null,
        'weeklyScheduleTemporalOverride' => null,
        'batteryCoverOpen' => null,
        'calibrationError' => null,
        'mode' => null,
        'temperatureHeat' => null,
        'temperatureCool' => null,
        'temperatureMain' => null,
        'humidityMain' => null,
        'impulsesPerUnit' => null,
        'counter' => null,
        'calculatedValue' => null,
        'unit' => null,
        'currentOverload' => null,
        'isCalibrating' => null,
        'notCalibrated' => null,
        'shut' => null,
        'closed' => null,
        'manuallyClosed' => null,
        'flooding' => null,
        'executing' => null,
        'initiatorTypeId' => null,
        'initiatorType' => null,
        'initiatorId' => null,
        'initiatorName' => null,
        'millisecondsFromStart' => null,
        'millisecondsToEnd' => null,
        'tiltPercent' => null,
        'tiltAngle' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'connected' => false,
        'connectedCode' => false,
        'brightness' => false,
        'on' => false,
        'color' => false,
        'colorBrightness' => false,
        'depth' => false,
        'distance' => false,
        'value' => false,
        'support' => false,
        'totalCost' => false,
        'pricePerUnit' => false,
        'currency' => false,
        'phases' => false,
        'hi' => false,
        'partialHi' => false,
        'humidity' => false,
        'temperature' => false,
        'heating' => false,
        'cooling' => false,
        'manual' => false,
        'countdownTimer' => false,
        'thermometerError' => false,
        'clockError' => false,
        'forcedOffBySensor' => false,
        'weeklyScheduleTemporalOverride' => false,
        'batteryCoverOpen' => false,
        'calibrationError' => false,
        'mode' => false,
        'temperatureHeat' => false,
        'temperatureCool' => false,
        'temperatureMain' => false,
        'humidityMain' => false,
        'impulsesPerUnit' => false,
        'counter' => false,
        'calculatedValue' => false,
        'unit' => false,
        'currentOverload' => false,
        'isCalibrating' => false,
        'notCalibrated' => false,
        'shut' => false,
        'closed' => false,
        'manuallyClosed' => false,
        'flooding' => false,
        'executing' => false,
        'initiatorTypeId' => false,
        'initiatorType' => false,
        'initiatorId' => true,
        'initiatorName' => true,
        'millisecondsFromStart' => false,
        'millisecondsToEnd' => false,
        'tiltPercent' => false,
        'tiltAngle' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'connected' => 'connected',
        'connectedCode' => 'connectedCode',
        'brightness' => 'brightness',
        'on' => 'on',
        'color' => 'color',
        'colorBrightness' => 'color_brightness',
        'depth' => 'depth',
        'distance' => 'distance',
        'value' => 'value',
        'support' => 'support',
        'totalCost' => 'totalCost',
        'pricePerUnit' => 'pricePerUnit',
        'currency' => 'currency',
        'phases' => 'phases',
        'hi' => 'hi',
        'partialHi' => 'partial_hi',
        'humidity' => 'humidity',
        'temperature' => 'temperature',
        'heating' => 'heating',
        'cooling' => 'cooling',
        'manual' => 'manual',
        'countdownTimer' => 'countdownTimer',
        'thermometerError' => 'thermometerError',
        'clockError' => 'clockError',
        'forcedOffBySensor' => 'forcedOffBySensor',
        'weeklyScheduleTemporalOverride' => 'weeklyScheduleTemporalOverride',
        'batteryCoverOpen' => 'batteryCoverOpen',
        'calibrationError' => 'calibrationError',
        'mode' => 'mode',
        'temperatureHeat' => 'temperatureHeat',
        'temperatureCool' => 'temperatureCool',
        'temperatureMain' => 'temperatureMain',
        'humidityMain' => 'humidityMain',
        'impulsesPerUnit' => 'impulsesPerUnit',
        'counter' => 'counter',
        'calculatedValue' => 'calculatedValue',
        'unit' => 'unit',
        'currentOverload' => 'currentOverload',
        'isCalibrating' => 'isCalibrating',
        'notCalibrated' => 'notCalibrated',
        'shut' => 'shut',
        'closed' => 'closed',
        'manuallyClosed' => 'manuallyClosed',
        'flooding' => 'flooding',
        'executing' => 'executing',
        'initiatorTypeId' => 'initiatorTypeId',
        'initiatorType' => 'initiatorType',
        'initiatorId' => 'initiatorId',
        'initiatorName' => 'initiatorName',
        'millisecondsFromStart' => 'millisecondsFromStart',
        'millisecondsToEnd' => 'millisecondsToEnd',
        'tiltPercent' => 'tiltPercent',
        'tiltAngle' => 'tiltAngle'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'connected' => 'setConnected',
        'connectedCode' => 'setConnectedCode',
        'brightness' => 'setBrightness',
        'on' => 'setOn',
        'color' => 'setColor',
        'colorBrightness' => 'setColorBrightness',
        'depth' => 'setDepth',
        'distance' => 'setDistance',
        'value' => 'setValue',
        'support' => 'setSupport',
        'totalCost' => 'setTotalCost',
        'pricePerUnit' => 'setPricePerUnit',
        'currency' => 'setCurrency',
        'phases' => 'setPhases',
        'hi' => 'setHi',
        'partialHi' => 'setPartialHi',
        'humidity' => 'setHumidity',
        'temperature' => 'setTemperature',
        'heating' => 'setHeating',
        'cooling' => 'setCooling',
        'manual' => 'setManual',
        'countdownTimer' => 'setCountdownTimer',
        'thermometerError' => 'setThermometerError',
        'clockError' => 'setClockError',
        'forcedOffBySensor' => 'setForcedOffBySensor',
        'weeklyScheduleTemporalOverride' => 'setWeeklyScheduleTemporalOverride',
        'batteryCoverOpen' => 'setBatteryCoverOpen',
        'calibrationError' => 'setCalibrationError',
        'mode' => 'setMode',
        'temperatureHeat' => 'setTemperatureHeat',
        'temperatureCool' => 'setTemperatureCool',
        'temperatureMain' => 'setTemperatureMain',
        'humidityMain' => 'setHumidityMain',
        'impulsesPerUnit' => 'setImpulsesPerUnit',
        'counter' => 'setCounter',
        'calculatedValue' => 'setCalculatedValue',
        'unit' => 'setUnit',
        'currentOverload' => 'setCurrentOverload',
        'isCalibrating' => 'setIsCalibrating',
        'notCalibrated' => 'setNotCalibrated',
        'shut' => 'setShut',
        'closed' => 'setClosed',
        'manuallyClosed' => 'setManuallyClosed',
        'flooding' => 'setFlooding',
        'executing' => 'setExecuting',
        'initiatorTypeId' => 'setInitiatorTypeId',
        'initiatorType' => 'setInitiatorType',
        'initiatorId' => 'setInitiatorId',
        'initiatorName' => 'setInitiatorName',
        'millisecondsFromStart' => 'setMillisecondsFromStart',
        'millisecondsToEnd' => 'setMillisecondsToEnd',
        'tiltPercent' => 'setTiltPercent',
        'tiltAngle' => 'setTiltAngle'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'connected' => 'getConnected',
        'connectedCode' => 'getConnectedCode',
        'brightness' => 'getBrightness',
        'on' => 'getOn',
        'color' => 'getColor',
        'colorBrightness' => 'getColorBrightness',
        'depth' => 'getDepth',
        'distance' => 'getDistance',
        'value' => 'getValue',
        'support' => 'getSupport',
        'totalCost' => 'getTotalCost',
        'pricePerUnit' => 'getPricePerUnit',
        'currency' => 'getCurrency',
        'phases' => 'getPhases',
        'hi' => 'getHi',
        'partialHi' => 'getPartialHi',
        'humidity' => 'getHumidity',
        'temperature' => 'getTemperature',
        'heating' => 'getHeating',
        'cooling' => 'getCooling',
        'manual' => 'getManual',
        'countdownTimer' => 'getCountdownTimer',
        'thermometerError' => 'getThermometerError',
        'clockError' => 'getClockError',
        'forcedOffBySensor' => 'getForcedOffBySensor',
        'weeklyScheduleTemporalOverride' => 'getWeeklyScheduleTemporalOverride',
        'batteryCoverOpen' => 'getBatteryCoverOpen',
        'calibrationError' => 'getCalibrationError',
        'mode' => 'getMode',
        'temperatureHeat' => 'getTemperatureHeat',
        'temperatureCool' => 'getTemperatureCool',
        'temperatureMain' => 'getTemperatureMain',
        'humidityMain' => 'getHumidityMain',
        'impulsesPerUnit' => 'getImpulsesPerUnit',
        'counter' => 'getCounter',
        'calculatedValue' => 'getCalculatedValue',
        'unit' => 'getUnit',
        'currentOverload' => 'getCurrentOverload',
        'isCalibrating' => 'getIsCalibrating',
        'notCalibrated' => 'getNotCalibrated',
        'shut' => 'getShut',
        'closed' => 'getClosed',
        'manuallyClosed' => 'getManuallyClosed',
        'flooding' => 'getFlooding',
        'executing' => 'getExecuting',
        'initiatorTypeId' => 'getInitiatorTypeId',
        'initiatorType' => 'getInitiatorType',
        'initiatorId' => 'getInitiatorId',
        'initiatorName' => 'getInitiatorName',
        'millisecondsFromStart' => 'getMillisecondsFromStart',
        'millisecondsToEnd' => 'getMillisecondsToEnd',
        'tiltPercent' => 'getTiltPercent',
        'tiltAngle' => 'getTiltAngle'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const INITIATOR_TYPE_ID_NUMBER_0 = 0;
    public const INITIATOR_TYPE_ID_NUMBER_1 = 1;
    public const INITIATOR_TYPE_ID_NUMBER_2 = 2;
    public const INITIATOR_TYPE_ID_NUMBER_3 = 3;
    public const INITIATOR_TYPE_ID_NUMBER_4 = 4;
    public const INITIATOR_TYPE_ID_NUMBER_5 = 5;
    public const INITIATOR_TYPE_ID_NUMBER_6 = 6;
    public const INITIATOR_TYPE_ID_NUMBER_7 = 7;
    public const INITIATOR_TYPE_ID_NUMBER_8 = 8;
    public const INITIATOR_TYPE_UNKNOWN = 'UNKNOWN';
    public const INITIATOR_TYPE_DEVICE = 'DEVICE';
    public const INITIATOR_TYPE_CLIENT = 'CLIENT';
    public const INITIATOR_TYPE_IPC = 'IPC';
    public const INITIATOR_TYPE_MQTT = 'MQTT';
    public const INITIATOR_TYPE_AMAZON_ALEXA = 'AMAZON_ALEXA';
    public const INITIATOR_TYPE_GOOGLE_HOME = 'GOOGLE_HOME';
    public const INITIATOR_TYPE_ACTION_TRIGGER = 'ACTION_TRIGGER';
    public const INITIATOR_TYPE_SCENE = 'SCENE';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getInitiatorTypeIdAllowableValues()
    {
        return [
            self::INITIATOR_TYPE_ID_NUMBER_0,
            self::INITIATOR_TYPE_ID_NUMBER_1,
            self::INITIATOR_TYPE_ID_NUMBER_2,
            self::INITIATOR_TYPE_ID_NUMBER_3,
            self::INITIATOR_TYPE_ID_NUMBER_4,
            self::INITIATOR_TYPE_ID_NUMBER_5,
            self::INITIATOR_TYPE_ID_NUMBER_6,
            self::INITIATOR_TYPE_ID_NUMBER_7,
            self::INITIATOR_TYPE_ID_NUMBER_8,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getInitiatorTypeAllowableValues()
    {
        return [
            self::INITIATOR_TYPE_UNKNOWN,
            self::INITIATOR_TYPE_DEVICE,
            self::INITIATOR_TYPE_CLIENT,
            self::INITIATOR_TYPE_IPC,
            self::INITIATOR_TYPE_MQTT,
            self::INITIATOR_TYPE_AMAZON_ALEXA,
            self::INITIATOR_TYPE_GOOGLE_HOME,
            self::INITIATOR_TYPE_ACTION_TRIGGER,
            self::INITIATOR_TYPE_SCENE,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('connected', $data ?? [], null);
        $this->setIfExists('connectedCode', $data ?? [], null);
        $this->setIfExists('brightness', $data ?? [], null);
        $this->setIfExists('on', $data ?? [], null);
        $this->setIfExists('color', $data ?? [], null);
        $this->setIfExists('colorBrightness', $data ?? [], null);
        $this->setIfExists('depth', $data ?? [], null);
        $this->setIfExists('distance', $data ?? [], null);
        $this->setIfExists('value', $data ?? [], null);
        $this->setIfExists('support', $data ?? [], null);
        $this->setIfExists('totalCost', $data ?? [], null);
        $this->setIfExists('pricePerUnit', $data ?? [], null);
        $this->setIfExists('currency', $data ?? [], null);
        $this->setIfExists('phases', $data ?? [], null);
        $this->setIfExists('hi', $data ?? [], null);
        $this->setIfExists('partialHi', $data ?? [], null);
        $this->setIfExists('humidity', $data ?? [], null);
        $this->setIfExists('temperature', $data ?? [], null);
        $this->setIfExists('heating', $data ?? [], null);
        $this->setIfExists('cooling', $data ?? [], null);
        $this->setIfExists('manual', $data ?? [], null);
        $this->setIfExists('countdownTimer', $data ?? [], null);
        $this->setIfExists('thermometerError', $data ?? [], null);
        $this->setIfExists('clockError', $data ?? [], null);
        $this->setIfExists('forcedOffBySensor', $data ?? [], null);
        $this->setIfExists('weeklyScheduleTemporalOverride', $data ?? [], null);
        $this->setIfExists('batteryCoverOpen', $data ?? [], null);
        $this->setIfExists('calibrationError', $data ?? [], null);
        $this->setIfExists('mode', $data ?? [], null);
        $this->setIfExists('temperatureHeat', $data ?? [], null);
        $this->setIfExists('temperatureCool', $data ?? [], null);
        $this->setIfExists('temperatureMain', $data ?? [], null);
        $this->setIfExists('humidityMain', $data ?? [], null);
        $this->setIfExists('impulsesPerUnit', $data ?? [], null);
        $this->setIfExists('counter', $data ?? [], null);
        $this->setIfExists('calculatedValue', $data ?? [], null);
        $this->setIfExists('unit', $data ?? [], null);
        $this->setIfExists('currentOverload', $data ?? [], null);
        $this->setIfExists('isCalibrating', $data ?? [], null);
        $this->setIfExists('notCalibrated', $data ?? [], null);
        $this->setIfExists('shut', $data ?? [], null);
        $this->setIfExists('closed', $data ?? [], null);
        $this->setIfExists('manuallyClosed', $data ?? [], null);
        $this->setIfExists('flooding', $data ?? [], null);
        $this->setIfExists('executing', $data ?? [], null);
        $this->setIfExists('initiatorTypeId', $data ?? [], null);
        $this->setIfExists('initiatorType', $data ?? [], null);
        $this->setIfExists('initiatorId', $data ?? [], null);
        $this->setIfExists('initiatorName', $data ?? [], null);
        $this->setIfExists('millisecondsFromStart', $data ?? [], null);
        $this->setIfExists('millisecondsToEnd', $data ?? [], null);
        $this->setIfExists('tiltPercent', $data ?? [], null);
        $this->setIfExists('tiltAngle', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (!is_null($this->container['brightness']) && ($this->container['brightness'] > 100)) {
            $invalidProperties[] = "invalid value for 'brightness', must be smaller than or equal to 100.";
        }

        if (!is_null($this->container['brightness']) && ($this->container['brightness'] < 0)) {
            $invalidProperties[] = "invalid value for 'brightness', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['colorBrightness']) && ($this->container['colorBrightness'] > 100)) {
            $invalidProperties[] = "invalid value for 'colorBrightness', must be smaller than or equal to 100.";
        }

        if (!is_null($this->container['colorBrightness']) && ($this->container['colorBrightness'] < 0)) {
            $invalidProperties[] = "invalid value for 'colorBrightness', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['depth']) && ($this->container['depth'] < 0)) {
            $invalidProperties[] = "invalid value for 'depth', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['distance']) && ($this->container['distance'] < 0)) {
            $invalidProperties[] = "invalid value for 'distance', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['humidity']) && ($this->container['humidity'] > 100)) {
            $invalidProperties[] = "invalid value for 'humidity', must be smaller than or equal to 100.";
        }

        if (!is_null($this->container['humidity']) && ($this->container['humidity'] < 0)) {
            $invalidProperties[] = "invalid value for 'humidity', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['shut']) && ($this->container['shut'] > 100)) {
            $invalidProperties[] = "invalid value for 'shut', must be smaller than or equal to 100.";
        }

        if (!is_null($this->container['shut']) && ($this->container['shut'] < 0)) {
            $invalidProperties[] = "invalid value for 'shut', must be bigger than or equal to 0.";
        }

        if ($this->container['executing'] === null) {
            $invalidProperties[] = "'executing' can't be null";
        }
        $allowedValues = $this->getInitiatorTypeIdAllowableValues();
        if (!is_null($this->container['initiatorTypeId']) && !in_array($this->container['initiatorTypeId'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'initiatorTypeId', must be one of '%s'",
                $this->container['initiatorTypeId'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getInitiatorTypeAllowableValues();
        if (!is_null($this->container['initiatorType']) && !in_array($this->container['initiatorType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'initiatorType', must be one of '%s'",
                $this->container['initiatorType'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['tiltPercent']) && ($this->container['tiltPercent'] > 100)) {
            $invalidProperties[] = "invalid value for 'tiltPercent', must be smaller than or equal to 100.";
        }

        if (!is_null($this->container['tiltPercent']) && ($this->container['tiltPercent'] < 0)) {
            $invalidProperties[] = "invalid value for 'tiltPercent', must be bigger than or equal to 0.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets connected
     *
     * @return bool|null
     */
    public function getConnected()
    {
        return $this->container['connected'];
    }

    /**
     * Sets connected
     *
     * @param bool|null $connected connected
     *
     * @return self
     */
    public function setConnected($connected)
    {
        if (is_null($connected)) {
            throw new \InvalidArgumentException('non-nullable connected cannot be null');
        }
        $this->container['connected'] = $connected;

        return $this;
    }

    /**
     * Gets connectedCode
     *
     * @return string|null
     */
    public function getConnectedCode()
    {
        return $this->container['connectedCode'];
    }

    /**
     * Sets connectedCode
     *
     * @param string|null $connectedCode connectedCode
     *
     * @return self
     */
    public function setConnectedCode($connectedCode)
    {
        if (is_null($connectedCode)) {
            throw new \InvalidArgumentException('non-nullable connectedCode cannot be null');
        }
        $this->container['connectedCode'] = $connectedCode;

        return $this;
    }

    /**
     * Gets brightness
     *
     * @return int|null
     */
    public function getBrightness()
    {
        return $this->container['brightness'];
    }

    /**
     * Sets brightness
     *
     * @param int|null $brightness current dimmer brightness value in percent
     *
     * @return self
     */
    public function setBrightness($brightness)
    {
        if (is_null($brightness)) {
            throw new \InvalidArgumentException('non-nullable brightness cannot be null');
        }

        if (($brightness > 100)) {
            throw new \InvalidArgumentException('invalid value for $brightness when calling ChannelState., must be smaller than or equal to 100.');
        }
        if (($brightness < 0)) {
            throw new \InvalidArgumentException('invalid value for $brightness when calling ChannelState., must be bigger than or equal to 0.');
        }

        $this->container['brightness'] = $brightness;

        return $this;
    }

    /**
     * Gets on
     *
     * @return bool|null
     */
    public function getOn()
    {
        return $this->container['on'];
    }

    /**
     * Sets on
     *
     * @param bool|null $on on
     *
     * @return self
     */
    public function setOn($on)
    {
        if (is_null($on)) {
            throw new \InvalidArgumentException('non-nullable on cannot be null');
        }
        $this->container['on'] = $on;

        return $this;
    }

    /**
     * Gets color
     *
     * @return string|null
     */
    public function getColor()
    {
        return $this->container['color'];
    }

    /**
     * Sets color
     *
     * @param string|null $color integer (hex) value of a current color, ranging from `0x000001` to `0xFFFFFF`
     *
     * @return self
     */
    public function setColor($color)
    {
        if (is_null($color)) {
            throw new \InvalidArgumentException('non-nullable color cannot be null');
        }
        $this->container['color'] = $color;

        return $this;
    }

    /**
     * Gets colorBrightness
     *
     * @return int|null
     */
    public function getColorBrightness()
    {
        return $this->container['colorBrightness'];
    }

    /**
     * Sets colorBrightness
     *
     * @param int|null $colorBrightness color brightness in percent
     *
     * @return self
     */
    public function setColorBrightness($colorBrightness)
    {
        if (is_null($colorBrightness)) {
            throw new \InvalidArgumentException('non-nullable colorBrightness cannot be null');
        }

        if (($colorBrightness > 100)) {
            throw new \InvalidArgumentException('invalid value for $colorBrightness when calling ChannelState., must be smaller than or equal to 100.');
        }
        if (($colorBrightness < 0)) {
            throw new \InvalidArgumentException('invalid value for $colorBrightness when calling ChannelState., must be bigger than or equal to 0.');
        }

        $this->container['colorBrightness'] = $colorBrightness;

        return $this;
    }

    /**
     * Gets depth
     *
     * @return int|null
     */
    public function getDepth()
    {
        return $this->container['depth'];
    }

    /**
     * Sets depth
     *
     * @param int|null $depth depth
     *
     * @return self
     */
    public function setDepth($depth)
    {
        if (is_null($depth)) {
            throw new \InvalidArgumentException('non-nullable depth cannot be null');
        }

        if (($depth < 0)) {
            throw new \InvalidArgumentException('invalid value for $depth when calling ChannelState., must be bigger than or equal to 0.');
        }

        $this->container['depth'] = $depth;

        return $this;
    }

    /**
     * Gets distance
     *
     * @return int|null
     */
    public function getDistance()
    {
        return $this->container['distance'];
    }

    /**
     * Sets distance
     *
     * @param int|null $distance distance
     *
     * @return self
     */
    public function setDistance($distance)
    {
        if (is_null($distance)) {
            throw new \InvalidArgumentException('non-nullable distance cannot be null');
        }

        if (($distance < 0)) {
            throw new \InvalidArgumentException('invalid value for $distance when calling ChannelState., must be bigger than or equal to 0.');
        }

        $this->container['distance'] = $distance;

        return $this;
    }

    /**
     * Gets value
     *
     * @return float|null
     */
    public function getValue()
    {
        return $this->container['value'];
    }

    /**
     * Sets value
     *
     * @param float|null $value value
     *
     * @return self
     */
    public function setValue($value)
    {
        if (is_null($value)) {
            throw new \InvalidArgumentException('non-nullable value cannot be null');
        }
        $this->container['value'] = $value;

        return $this;
    }

    /**
     * Gets support
     *
     * @return int|null
     */
    public function getSupport()
    {
        return $this->container['support'];
    }

    /**
     * Sets support
     *
     * @param int|null $support A bitmask indicating which measurements are supported by the electricity meter. See https://github.com/SUPLA/supla-cloud/blob/master/src/SuplaBundle/Enums/ElectricityMeterSupportBits.php for more info. All not supported measurements will not be present in the response.
     *
     * @return self
     */
    public function setSupport($support)
    {
        if (is_null($support)) {
            throw new \InvalidArgumentException('non-nullable support cannot be null');
        }
        $this->container['support'] = $support;

        return $this;
    }

    /**
     * Gets totalCost
     *
     * @return float|null
     */
    public function getTotalCost()
    {
        return $this->container['totalCost'];
    }

    /**
     * Sets totalCost
     *
     * @param float|null $totalCost totalCost
     *
     * @return self
     */
    public function setTotalCost($totalCost)
    {
        if (is_null($totalCost)) {
            throw new \InvalidArgumentException('non-nullable totalCost cannot be null');
        }
        $this->container['totalCost'] = $totalCost;

        return $this;
    }

    /**
     * Gets pricePerUnit
     *
     * @return float|null
     */
    public function getPricePerUnit()
    {
        return $this->container['pricePerUnit'];
    }

    /**
     * Sets pricePerUnit
     *
     * @param float|null $pricePerUnit pricePerUnit
     *
     * @return self
     */
    public function setPricePerUnit($pricePerUnit)
    {
        if (is_null($pricePerUnit)) {
            throw new \InvalidArgumentException('non-nullable pricePerUnit cannot be null');
        }
        $this->container['pricePerUnit'] = $pricePerUnit;

        return $this;
    }

    /**
     * Gets currency
     *
     * @return string|null
     */
    public function getCurrency()
    {
        return $this->container['currency'];
    }

    /**
     * Sets currency
     *
     * @param string|null $currency currency
     *
     * @return self
     */
    public function setCurrency($currency)
    {
        if (is_null($currency)) {
            throw new \InvalidArgumentException('non-nullable currency cannot be null');
        }
        $this->container['currency'] = $currency;

        return $this;
    }

    /**
     * Gets phases
     *
     * @return \Supla\ApiClient\Model\ChannelStateElectricityMeterPhase[]|null
     */
    public function getPhases()
    {
        return $this->container['phases'];
    }

    /**
     * Sets phases
     *
     * @param \Supla\ApiClient\Model\ChannelStateElectricityMeterPhase[]|null $phases phases
     *
     * @return self
     */
    public function setPhases($phases)
    {
        if (is_null($phases)) {
            throw new \InvalidArgumentException('non-nullable phases cannot be null');
        }
        $this->container['phases'] = $phases;

        return $this;
    }

    /**
     * Gets hi
     *
     * @return bool|null
     */
    public function getHi()
    {
        return $this->container['hi'];
    }

    /**
     * Sets hi
     *
     * @param bool|null $hi hi
     *
     * @return self
     */
    public function setHi($hi)
    {
        if (is_null($hi)) {
            throw new \InvalidArgumentException('non-nullable hi cannot be null');
        }
        $this->container['hi'] = $hi;

        return $this;
    }

    /**
     * Gets partialHi
     *
     * @return bool|null
     */
    public function getPartialHi()
    {
        return $this->container['partialHi'];
    }

    /**
     * Sets partialHi
     *
     * @param bool|null $partialHi partialHi
     *
     * @return self
     */
    public function setPartialHi($partialHi)
    {
        if (is_null($partialHi)) {
            throw new \InvalidArgumentException('non-nullable partialHi cannot be null');
        }
        $this->container['partialHi'] = $partialHi;

        return $this;
    }

    /**
     * Gets humidity
     *
     * @return float|null
     */
    public function getHumidity()
    {
        return $this->container['humidity'];
    }

    /**
     * Sets humidity
     *
     * @param float|null $humidity value provided by the sensor, including possibly configured delta adjustment
     *
     * @return self
     */
    public function setHumidity($humidity)
    {
        if (is_null($humidity)) {
            throw new \InvalidArgumentException('non-nullable humidity cannot be null');
        }

        if (($humidity > 100)) {
            throw new \InvalidArgumentException('invalid value for $humidity when calling ChannelState., must be smaller than or equal to 100.');
        }
        if (($humidity < 0)) {
            throw new \InvalidArgumentException('invalid value for $humidity when calling ChannelState., must be bigger than or equal to 0.');
        }

        $this->container['humidity'] = $humidity;

        return $this;
    }

    /**
     * Gets temperature
     *
     * @return float|null
     */
    public function getTemperature()
    {
        return $this->container['temperature'];
    }

    /**
     * Sets temperature
     *
     * @param float|null $temperature value provided by the sensor, including possibly configured delta adjustment
     *
     * @return self
     */
    public function setTemperature($temperature)
    {
        if (is_null($temperature)) {
            throw new \InvalidArgumentException('non-nullable temperature cannot be null');
        }
        $this->container['temperature'] = $temperature;

        return $this;
    }

    /**
     * Gets heating
     *
     * @return bool|null
     */
    public function getHeating()
    {
        return $this->container['heating'];
    }

    /**
     * Sets heating
     *
     * @param bool|null $heating heating
     *
     * @return self
     */
    public function setHeating($heating)
    {
        if (is_null($heating)) {
            throw new \InvalidArgumentException('non-nullable heating cannot be null');
        }
        $this->container['heating'] = $heating;

        return $this;
    }

    /**
     * Gets cooling
     *
     * @return bool|null
     */
    public function getCooling()
    {
        return $this->container['cooling'];
    }

    /**
     * Sets cooling
     *
     * @param bool|null $cooling cooling
     *
     * @return self
     */
    public function setCooling($cooling)
    {
        if (is_null($cooling)) {
            throw new \InvalidArgumentException('non-nullable cooling cannot be null');
        }
        $this->container['cooling'] = $cooling;

        return $this;
    }

    /**
     * Gets manual
     *
     * @return bool|null
     */
    public function getManual()
    {
        return $this->container['manual'];
    }

    /**
     * Sets manual
     *
     * @param bool|null $manual manual
     *
     * @return self
     */
    public function setManual($manual)
    {
        if (is_null($manual)) {
            throw new \InvalidArgumentException('non-nullable manual cannot be null');
        }
        $this->container['manual'] = $manual;

        return $this;
    }

    /**
     * Gets countdownTimer
     *
     * @return bool|null
     */
    public function getCountdownTimer()
    {
        return $this->container['countdownTimer'];
    }

    /**
     * Sets countdownTimer
     *
     * @param bool|null $countdownTimer countdownTimer
     *
     * @return self
     */
    public function setCountdownTimer($countdownTimer)
    {
        if (is_null($countdownTimer)) {
            throw new \InvalidArgumentException('non-nullable countdownTimer cannot be null');
        }
        $this->container['countdownTimer'] = $countdownTimer;

        return $this;
    }

    /**
     * Gets thermometerError
     *
     * @return bool|null
     */
    public function getThermometerError()
    {
        return $this->container['thermometerError'];
    }

    /**
     * Sets thermometerError
     *
     * @param bool|null $thermometerError thermometerError
     *
     * @return self
     */
    public function setThermometerError($thermometerError)
    {
        if (is_null($thermometerError)) {
            throw new \InvalidArgumentException('non-nullable thermometerError cannot be null');
        }
        $this->container['thermometerError'] = $thermometerError;

        return $this;
    }

    /**
     * Gets clockError
     *
     * @return bool|null
     */
    public function getClockError()
    {
        return $this->container['clockError'];
    }

    /**
     * Sets clockError
     *
     * @param bool|null $clockError clockError
     *
     * @return self
     */
    public function setClockError($clockError)
    {
        if (is_null($clockError)) {
            throw new \InvalidArgumentException('non-nullable clockError cannot be null');
        }
        $this->container['clockError'] = $clockError;

        return $this;
    }

    /**
     * Gets forcedOffBySensor
     *
     * @return bool|null
     */
    public function getForcedOffBySensor()
    {
        return $this->container['forcedOffBySensor'];
    }

    /**
     * Sets forcedOffBySensor
     *
     * @param bool|null $forcedOffBySensor forcedOffBySensor
     *
     * @return self
     */
    public function setForcedOffBySensor($forcedOffBySensor)
    {
        if (is_null($forcedOffBySensor)) {
            throw new \InvalidArgumentException('non-nullable forcedOffBySensor cannot be null');
        }
        $this->container['forcedOffBySensor'] = $forcedOffBySensor;

        return $this;
    }

    /**
     * Gets weeklyScheduleTemporalOverride
     *
     * @return bool|null
     */
    public function getWeeklyScheduleTemporalOverride()
    {
        return $this->container['weeklyScheduleTemporalOverride'];
    }

    /**
     * Sets weeklyScheduleTemporalOverride
     *
     * @param bool|null $weeklyScheduleTemporalOverride weeklyScheduleTemporalOverride
     *
     * @return self
     */
    public function setWeeklyScheduleTemporalOverride($weeklyScheduleTemporalOverride)
    {
        if (is_null($weeklyScheduleTemporalOverride)) {
            throw new \InvalidArgumentException('non-nullable weeklyScheduleTemporalOverride cannot be null');
        }
        $this->container['weeklyScheduleTemporalOverride'] = $weeklyScheduleTemporalOverride;

        return $this;
    }

    /**
     * Gets batteryCoverOpen
     *
     * @return bool|null
     */
    public function getBatteryCoverOpen()
    {
        return $this->container['batteryCoverOpen'];
    }

    /**
     * Sets batteryCoverOpen
     *
     * @param bool|null $batteryCoverOpen batteryCoverOpen
     *
     * @return self
     */
    public function setBatteryCoverOpen($batteryCoverOpen)
    {
        if (is_null($batteryCoverOpen)) {
            throw new \InvalidArgumentException('non-nullable batteryCoverOpen cannot be null');
        }
        $this->container['batteryCoverOpen'] = $batteryCoverOpen;

        return $this;
    }

    /**
     * Gets calibrationError
     *
     * @return bool|null
     */
    public function getCalibrationError()
    {
        return $this->container['calibrationError'];
    }

    /**
     * Sets calibrationError
     *
     * @param bool|null $calibrationError calibrationError
     *
     * @return self
     */
    public function setCalibrationError($calibrationError)
    {
        if (is_null($calibrationError)) {
            throw new \InvalidArgumentException('non-nullable calibrationError cannot be null');
        }
        $this->container['calibrationError'] = $calibrationError;

        return $this;
    }

    /**
     * Gets mode
     *
     * @return string|null
     */
    public function getMode()
    {
        return $this->container['mode'];
    }

    /**
     * Sets mode
     *
     * @param string|null $mode mode
     *
     * @return self
     */
    public function setMode($mode)
    {
        if (is_null($mode)) {
            throw new \InvalidArgumentException('non-nullable mode cannot be null');
        }
        $this->container['mode'] = $mode;

        return $this;
    }

    /**
     * Gets temperatureHeat
     *
     * @return float|null
     */
    public function getTemperatureHeat()
    {
        return $this->container['temperatureHeat'];
    }

    /**
     * Sets temperatureHeat
     *
     * @param float|null $temperatureHeat temperatureHeat
     *
     * @return self
     */
    public function setTemperatureHeat($temperatureHeat)
    {
        if (is_null($temperatureHeat)) {
            throw new \InvalidArgumentException('non-nullable temperatureHeat cannot be null');
        }
        $this->container['temperatureHeat'] = $temperatureHeat;

        return $this;
    }

    /**
     * Gets temperatureCool
     *
     * @return float|null
     */
    public function getTemperatureCool()
    {
        return $this->container['temperatureCool'];
    }

    /**
     * Sets temperatureCool
     *
     * @param float|null $temperatureCool temperatureCool
     *
     * @return self
     */
    public function setTemperatureCool($temperatureCool)
    {
        if (is_null($temperatureCool)) {
            throw new \InvalidArgumentException('non-nullable temperatureCool cannot be null');
        }
        $this->container['temperatureCool'] = $temperatureCool;

        return $this;
    }

    /**
     * Gets temperatureMain
     *
     * @return float|null
     */
    public function getTemperatureMain()
    {
        return $this->container['temperatureMain'];
    }

    /**
     * Sets temperatureMain
     *
     * @param float|null $temperatureMain temperatureMain
     *
     * @return self
     */
    public function setTemperatureMain($temperatureMain)
    {
        if (is_null($temperatureMain)) {
            throw new \InvalidArgumentException('non-nullable temperatureMain cannot be null');
        }
        $this->container['temperatureMain'] = $temperatureMain;

        return $this;
    }

    /**
     * Gets humidityMain
     *
     * @return float|null
     */
    public function getHumidityMain()
    {
        return $this->container['humidityMain'];
    }

    /**
     * Sets humidityMain
     *
     * @param float|null $humidityMain humidityMain
     *
     * @return self
     */
    public function setHumidityMain($humidityMain)
    {
        if (is_null($humidityMain)) {
            throw new \InvalidArgumentException('non-nullable humidityMain cannot be null');
        }
        $this->container['humidityMain'] = $humidityMain;

        return $this;
    }

    /**
     * Gets impulsesPerUnit
     *
     * @return int|null
     */
    public function getImpulsesPerUnit()
    {
        return $this->container['impulsesPerUnit'];
    }

    /**
     * Sets impulsesPerUnit
     *
     * @param int|null $impulsesPerUnit impulsesPerUnit
     *
     * @return self
     */
    public function setImpulsesPerUnit($impulsesPerUnit)
    {
        if (is_null($impulsesPerUnit)) {
            throw new \InvalidArgumentException('non-nullable impulsesPerUnit cannot be null');
        }
        $this->container['impulsesPerUnit'] = $impulsesPerUnit;

        return $this;
    }

    /**
     * Gets counter
     *
     * @return int|null
     */
    public function getCounter()
    {
        return $this->container['counter'];
    }

    /**
     * Sets counter
     *
     * @param int|null $counter counter
     *
     * @return self
     */
    public function setCounter($counter)
    {
        if (is_null($counter)) {
            throw new \InvalidArgumentException('non-nullable counter cannot be null');
        }
        $this->container['counter'] = $counter;

        return $this;
    }

    /**
     * Gets calculatedValue
     *
     * @return float|null
     */
    public function getCalculatedValue()
    {
        return $this->container['calculatedValue'];
    }

    /**
     * Sets calculatedValue
     *
     * @param float|null $calculatedValue calculatedValue
     *
     * @return self
     */
    public function setCalculatedValue($calculatedValue)
    {
        if (is_null($calculatedValue)) {
            throw new \InvalidArgumentException('non-nullable calculatedValue cannot be null');
        }
        $this->container['calculatedValue'] = $calculatedValue;

        return $this;
    }

    /**
     * Gets unit
     *
     * @return string|null
     */
    public function getUnit()
    {
        return $this->container['unit'];
    }

    /**
     * Sets unit
     *
     * @param string|null $unit unit
     *
     * @return self
     */
    public function setUnit($unit)
    {
        if (is_null($unit)) {
            throw new \InvalidArgumentException('non-nullable unit cannot be null');
        }
        $this->container['unit'] = $unit;

        return $this;
    }

    /**
     * Gets currentOverload
     *
     * @return bool|null
     */
    public function getCurrentOverload()
    {
        return $this->container['currentOverload'];
    }

    /**
     * Sets currentOverload
     *
     * @param bool|null $currentOverload currentOverload
     *
     * @return self
     */
    public function setCurrentOverload($currentOverload)
    {
        if (is_null($currentOverload)) {
            throw new \InvalidArgumentException('non-nullable currentOverload cannot be null');
        }
        $this->container['currentOverload'] = $currentOverload;

        return $this;
    }

    /**
     * Gets isCalibrating
     *
     * @return bool|null
     */
    public function getIsCalibrating()
    {
        return $this->container['isCalibrating'];
    }

    /**
     * Sets isCalibrating
     *
     * @param bool|null $isCalibrating isCalibrating
     *
     * @return self
     */
    public function setIsCalibrating($isCalibrating)
    {
        if (is_null($isCalibrating)) {
            throw new \InvalidArgumentException('non-nullable isCalibrating cannot be null');
        }
        $this->container['isCalibrating'] = $isCalibrating;

        return $this;
    }

    /**
     * Gets notCalibrated
     *
     * @return bool|null
     */
    public function getNotCalibrated()
    {
        return $this->container['notCalibrated'];
    }

    /**
     * Sets notCalibrated
     *
     * @param bool|null $notCalibrated notCalibrated
     *
     * @return self
     */
    public function setNotCalibrated($notCalibrated)
    {
        if (is_null($notCalibrated)) {
            throw new \InvalidArgumentException('non-nullable notCalibrated cannot be null');
        }
        $this->container['notCalibrated'] = $notCalibrated;

        return $this;
    }

    /**
     * Gets shut
     *
     * @return int|null
     */
    public function getShut()
    {
        return $this->container['shut'];
    }

    /**
     * Sets shut
     *
     * @param int|null $shut shut
     *
     * @return self
     */
    public function setShut($shut)
    {
        if (is_null($shut)) {
            throw new \InvalidArgumentException('non-nullable shut cannot be null');
        }

        if (($shut > 100)) {
            throw new \InvalidArgumentException('invalid value for $shut when calling ChannelState., must be smaller than or equal to 100.');
        }
        if (($shut < 0)) {
            throw new \InvalidArgumentException('invalid value for $shut when calling ChannelState., must be bigger than or equal to 0.');
        }

        $this->container['shut'] = $shut;

        return $this;
    }

    /**
     * Gets closed
     *
     * @return bool|null
     */
    public function getClosed()
    {
        return $this->container['closed'];
    }

    /**
     * Sets closed
     *
     * @param bool|null $closed closed
     *
     * @return self
     */
    public function setClosed($closed)
    {
        if (is_null($closed)) {
            throw new \InvalidArgumentException('non-nullable closed cannot be null');
        }
        $this->container['closed'] = $closed;

        return $this;
    }

    /**
     * Gets manuallyClosed
     *
     * @return bool|null
     */
    public function getManuallyClosed()
    {
        return $this->container['manuallyClosed'];
    }

    /**
     * Sets manuallyClosed
     *
     * @param bool|null $manuallyClosed manuallyClosed
     *
     * @return self
     */
    public function setManuallyClosed($manuallyClosed)
    {
        if (is_null($manuallyClosed)) {
            throw new \InvalidArgumentException('non-nullable manuallyClosed cannot be null');
        }
        $this->container['manuallyClosed'] = $manuallyClosed;

        return $this;
    }

    /**
     * Gets flooding
     *
     * @return bool|null
     */
    public function getFlooding()
    {
        return $this->container['flooding'];
    }

    /**
     * Sets flooding
     *
     * @param bool|null $flooding flooding
     *
     * @return self
     */
    public function setFlooding($flooding)
    {
        if (is_null($flooding)) {
            throw new \InvalidArgumentException('non-nullable flooding cannot be null');
        }
        $this->container['flooding'] = $flooding;

        return $this;
    }

    /**
     * Gets executing
     *
     * @return bool
     */
    public function getExecuting()
    {
        return $this->container['executing'];
    }

    /**
     * Sets executing
     *
     * @param bool $executing executing
     *
     * @return self
     */
    public function setExecuting($executing)
    {
        if (is_null($executing)) {
            throw new \InvalidArgumentException('non-nullable executing cannot be null');
        }
        $this->container['executing'] = $executing;

        return $this;
    }

    /**
     * Gets initiatorTypeId
     *
     * @return int|null
     */
    public function getInitiatorTypeId()
    {
        return $this->container['initiatorTypeId'];
    }

    /**
     * Sets initiatorTypeId
     *
     * @param int|null $initiatorTypeId initiatorTypeId
     *
     * @return self
     */
    public function setInitiatorTypeId($initiatorTypeId)
    {
        if (is_null($initiatorTypeId)) {
            throw new \InvalidArgumentException('non-nullable initiatorTypeId cannot be null');
        }
        $allowedValues = $this->getInitiatorTypeIdAllowableValues();
        if (!in_array($initiatorTypeId, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'initiatorTypeId', must be one of '%s'",
                    $initiatorTypeId,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['initiatorTypeId'] = $initiatorTypeId;

        return $this;
    }

    /**
     * Gets initiatorType
     *
     * @return string|null
     */
    public function getInitiatorType()
    {
        return $this->container['initiatorType'];
    }

    /**
     * Sets initiatorType
     *
     * @param string|null $initiatorType initiatorType
     *
     * @return self
     */
    public function setInitiatorType($initiatorType)
    {
        if (is_null($initiatorType)) {
            throw new \InvalidArgumentException('non-nullable initiatorType cannot be null');
        }
        $allowedValues = $this->getInitiatorTypeAllowableValues();
        if (!in_array($initiatorType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'initiatorType', must be one of '%s'",
                    $initiatorType,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['initiatorType'] = $initiatorType;

        return $this;
    }

    /**
     * Gets initiatorId
     *
     * @return int|null
     */
    public function getInitiatorId()
    {
        return $this->container['initiatorId'];
    }

    /**
     * Sets initiatorId
     *
     * @param int|null $initiatorId initiatorId
     *
     * @return self
     */
    public function setInitiatorId($initiatorId)
    {
        if (is_null($initiatorId)) {
            array_push($this->openAPINullablesSetToNull, 'initiatorId');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('initiatorId', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['initiatorId'] = $initiatorId;

        return $this;
    }

    /**
     * Gets initiatorName
     *
     * @return string|null
     */
    public function getInitiatorName()
    {
        return $this->container['initiatorName'];
    }

    /**
     * Sets initiatorName
     *
     * @param string|null $initiatorName initiatorName
     *
     * @return self
     */
    public function setInitiatorName($initiatorName)
    {
        if (is_null($initiatorName)) {
            array_push($this->openAPINullablesSetToNull, 'initiatorName');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('initiatorName', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['initiatorName'] = $initiatorName;

        return $this;
    }

    /**
     * Gets millisecondsFromStart
     *
     * @return int|null
     */
    public function getMillisecondsFromStart()
    {
        return $this->container['millisecondsFromStart'];
    }

    /**
     * Sets millisecondsFromStart
     *
     * @param int|null $millisecondsFromStart millisecondsFromStart
     *
     * @return self
     */
    public function setMillisecondsFromStart($millisecondsFromStart)
    {
        if (is_null($millisecondsFromStart)) {
            throw new \InvalidArgumentException('non-nullable millisecondsFromStart cannot be null');
        }
        $this->container['millisecondsFromStart'] = $millisecondsFromStart;

        return $this;
    }

    /**
     * Gets millisecondsToEnd
     *
     * @return int|null
     */
    public function getMillisecondsToEnd()
    {
        return $this->container['millisecondsToEnd'];
    }

    /**
     * Sets millisecondsToEnd
     *
     * @param int|null $millisecondsToEnd millisecondsToEnd
     *
     * @return self
     */
    public function setMillisecondsToEnd($millisecondsToEnd)
    {
        if (is_null($millisecondsToEnd)) {
            throw new \InvalidArgumentException('non-nullable millisecondsToEnd cannot be null');
        }
        $this->container['millisecondsToEnd'] = $millisecondsToEnd;

        return $this;
    }

    /**
     * Gets tiltPercent
     *
     * @return int|null
     */
    public function getTiltPercent()
    {
        return $this->container['tiltPercent'];
    }

    /**
     * Sets tiltPercent
     *
     * @param int|null $tiltPercent tiltPercent
     *
     * @return self
     */
    public function setTiltPercent($tiltPercent)
    {
        if (is_null($tiltPercent)) {
            throw new \InvalidArgumentException('non-nullable tiltPercent cannot be null');
        }

        if (($tiltPercent > 100)) {
            throw new \InvalidArgumentException('invalid value for $tiltPercent when calling ChannelState., must be smaller than or equal to 100.');
        }
        if (($tiltPercent < 0)) {
            throw new \InvalidArgumentException('invalid value for $tiltPercent when calling ChannelState., must be bigger than or equal to 0.');
        }

        $this->container['tiltPercent'] = $tiltPercent;

        return $this;
    }

    /**
     * Gets tiltAngle
     *
     * @return int|null
     */
    public function getTiltAngle()
    {
        return $this->container['tiltAngle'];
    }

    /**
     * Sets tiltAngle
     *
     * @param int|null $tiltAngle tiltAngle
     *
     * @return self
     */
    public function setTiltAngle($tiltAngle)
    {
        if (is_null($tiltAngle)) {
            throw new \InvalidArgumentException('non-nullable tiltAngle cannot be null');
        }
        $this->container['tiltAngle'] = $tiltAngle;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


